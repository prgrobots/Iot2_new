# Session 08: Signal Processing & Vibration

**Week:** 8  
**Element:** ICTIOT502 Element 2: Program IoT device (test and rectify)  
**Duration:** 3.5 hours  
**Phase:** Electronics for Programmers

---

> **Note:** All electronics sessions can be completed using either Arduino (C++) or MicroPython on the ESP32. You may choose your preferred language for all programming tasks, code submissions, and portfolio checkpoints.

---

## Session Introduction

This week focuses on **signal processing** for the GY-521 accelerometer data from your base panel. You'll implement filtering algorithms to remove noise, detect vibration anomalies for predictive maintenance, and finalize **Assessment 3** (Tire & Suspension Health Monitor). This session bridges electronics and AWS – clean data processing is essential for cloud analytics.

## Learning Objectives

By the end of this session, you will be able to:

- Implement moving average filters for noisy sensor data
- Detect vibration anomalies using threshold algorithms
- Apply signal processing concepts from PhysComp
- Document fault rectification for sensor calibration
- Complete **Assessment 3** with predictive maintenance algorithm

---

## Session Structure

1. **Signal Processing Theory** – PhysComp review
2. **Moving Average Filter** – Smooth accelerometer data
3. **Anomaly Detection** – Threshold-based alerts
4. **Predictive Maintenance** – Vibration pattern analysis
5. **Assessment 3 Finalization** – Test plan execution

---

## Pre-Session Preparation

!!! info "Required Reading"
    - PhysComp → [Signal Processing](https://makeabilitylab.github.io/physcomp/signals/)
    - PhysComp → [Smoothing and Filtering](https://makeabilitylab.github.io/physcomp/signals/smoothing-filters.html)
    - Review GY-521 accelerometer code from Week 5

!!! tip "Setup Check"
    - [ ] ESP32 with GY-521 from base panel
    - [ ] Test setup: small motor or phone vibration for controlled vibration source
    - [ ] GitHub repo ready for Assessment 3 submission

---

## RockCore Mining Context

Tire failures on 400-ton haul trucks cost **$50,000+ per incident** and cause 8-hour downtime. Your **predictive maintenance system** must:

- Filter out road vibration noise (normal operation)
- Detect abnormal vibration patterns (tire imbalance, bearing wear)
- Alert maintenance crew **before** catastrophic failure

Today you'll implement the algorithm that processes GY-521 data and generates early warnings.

---

## Hands-On Tasks

### Task 1: Raw Accelerometer Data Collection

```cpp
// Week 8 Task 1 - Raw Vibration Data
#include <Wire.h>
#include <MPU6050.h>

MPU6050 mpu;

void setup() {
  Serial.begin(115200);
  Wire.begin();
  mpu.begin(MPU6050_SCALE_2000DPS, MPU6050_RANGE_2G);
  
  Serial.println("X,Y,Z,Magnitude");  // CSV header for plotting
}

void loop() {
  Vector accel = mpu.readNormalizeAccel();
  float magnitude = sqrt(accel.XAxis * accel.XAxis + 
                         accel.YAxis * accel.YAxis + 
                         accel.ZAxis * accel.ZAxis);
  
  // CSV format for data analysis
  Serial.print(accel.XAxis, 3);
  Serial.print(",");
  Serial.print(accel.YAxis, 3);
  Serial.print(",");
  Serial.print(accel.ZAxis, 3);
  Serial.print(",");
  Serial.println(magnitude, 3);
  
  delay(50);  // 20 Hz sampling rate
}
```

### Task 2: Moving Average Filter

```cpp
// Week 8 Task 2 - Moving Average Filter
#include <Wire.h>
#include <MPU6050.h>

MPU6050 mpu;

const int WINDOW_SIZE = 10;
float xBuffer[WINDOW_SIZE];
float yBuffer[WINDOW_SIZE];
float zBuffer[WINDOW_SIZE];
int bufferIndex = 0;

void setup() {
  Serial.begin(115200);
  Wire.begin();
  mpu.begin(MPU6050_SCALE_2000DPS, MPU6050_RANGE_2G);
  
  // Initialize buffers
  for (int i = 0; i < WINDOW_SIZE; i++) {
    xBuffer[i] = 0;
    yBuffer[i] = 0;
    zBuffer[i] = 0;
  }
  
  Serial.println("Raw_Mag,Filtered_Mag");
}

float movingAverage(float buffer[], float newValue) {
  buffer[bufferIndex] = newValue;
  
  float sum = 0;
  for (int i = 0; i < WINDOW_SIZE; i++) {
    sum += buffer[i];
  }
  
  return sum / WINDOW_SIZE;
}

void loop() {
  Vector accel = mpu.readNormalizeAccel();
  
  float rawMag = sqrt(accel.XAxis * accel.XAxis + 
                      accel.YAxis * accel.YAxis + 
                      accel.ZAxis * accel.ZAxis);
  
  float filteredX = movingAverage(xBuffer, accel.XAxis);
  float filteredY = movingAverage(yBuffer, accel.YAxis);
  float filteredZ = movingAverage(zBuffer, accel.ZAxis);
  
  float filteredMag = sqrt(filteredX * filteredX + 
                           filteredY * filteredY + 
                           filteredZ * filteredZ);
  
  Serial.print(rawMag, 3);
  Serial.print(",");
  Serial.println(filteredMag, 3);
  
  bufferIndex = (bufferIndex + 1) % WINDOW_SIZE;
  delay(50);
}
```

### Task 3: Anomaly Detection Algorithm

```cpp
// Week 8 Task 3 - Vibration Anomaly Detection
#include <Wire.h>
#include <MPU6050.h>

MPU6050 mpu;

const int WINDOW_SIZE = 20;
float magBuffer[WINDOW_SIZE];
int bufferIndex = 0;
bool bufferFilled = false;

float BASELINE_THRESHOLD = 1.2;  // Normal vibration
float ANOMALY_THRESHOLD = 1.8;   // Abnormal vibration
const int ALERT_PIN = 25;

void setup() {
  Serial.begin(115200);
  Wire.begin();
  mpu.begin(MPU6050_SCALE_2000DPS, MPU6050_RANGE_2G);
  pinMode(ALERT_PIN, OUTPUT);
  
  Serial.println("=== RockCore Predictive Maintenance ===");
}

float calculateMagnitude() {
  Vector accel = mpu.readNormalizeAccel();
  return sqrt(accel.XAxis * accel.XAxis + 
              accel.YAxis * accel.YAxis + 
              accel.ZAxis * accel.ZAxis);
}

float getAverage() {
  float sum = 0;
  int count = bufferFilled ? WINDOW_SIZE : bufferIndex;
  
  for (int i = 0; i < count; i++) {
    sum += magBuffer[i];
  }
  
  return sum / count;
}

void loop() {
  float magnitude = calculateMagnitude();
  
  // Add to buffer
  magBuffer[bufferIndex] = magnitude;
  bufferIndex++;
  
  if (bufferIndex >= WINDOW_SIZE) {
    bufferFilled = true;
    bufferIndex = 0;
  }
  
  if (!bufferFilled) {
    Serial.println("Calibrating baseline...");
    delay(100);
    return;
  }
  
  float average = getAverage();
  
  Serial.print("Current: ");
  Serial.print(magnitude, 3);
  Serial.print(" | Average: ");
  Serial.print(average, 3);
  
  // Anomaly detection
  if (magnitude > ANOMALY_THRESHOLD) {
    digitalWrite(ALERT_PIN, HIGH);
    Serial.println(" | CRITICAL: Severe vibration - inspect tires/bearings");
  } else if (magnitude > BASELINE_THRESHOLD) {
    digitalWrite(ALERT_PIN, LOW);
    Serial.println(" | WARNING: Elevated vibration");
  } else {
    digitalWrite(ALERT_PIN, LOW);
    Serial.println(" | NORMAL");
  }
  
  delay(100);
}
```

### Task 4: Complete Predictive Maintenance System (Assessment 3)

```cpp
// Week 8 Task 4 - Full Assessment 3 System
#include <Wire.h>
#include <MPU6050.h>
#include <Adafruit_SSD1306.h>

MPU6050 mpu;
Adafruit_SSD1306 display(128, 64, &Wire, -1);

const int WINDOW_SIZE = 20;
float magBuffer[WINDOW_SIZE];
int bufferIndex = 0;
bool bufferFilled = false;

float BASELINE = 1.2;
float WARNING = 1.5;
float CRITICAL = 1.8;

int anomalyCount = 0;
unsigned long lastAnomaly = 0;

void setup() {
  Serial.begin(115200);
  Wire.begin();
  mpu.begin(MPU6050_SCALE_2000DPS, MPU6050_RANGE_2G);
  display.begin(SSD1306_SWITCHCAPVCC, 0x3C);
  
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(0,0);
  display.println("RockCore Truck");
  display.println("Vibration Monitor");
  display.println("Initializing...");
  display.display();
  
  Serial.println("=== Tire & Suspension Health Monitor ===");
}

float getMagnitude() {
  Vector accel = mpu.readNormalizeAccel();
  return sqrt(accel.XAxis * accel.XAxis + 
              accel.YAxis * accel.YAxis + 
              accel.ZAxis * accel.ZAxis);
}

String getStatus(float mag) {
  if (mag > CRITICAL) return "CRITICAL";
  if (mag > WARNING) return "WARNING";
  if (mag > BASELINE) return "ELEVATED";
  return "NORMAL";
}

void loop() {
  float mag = getMagnitude();
  
  magBuffer[bufferIndex] = mag;
  bufferIndex = (bufferIndex + 1) % WINDOW_SIZE;
  if (bufferIndex == 0) bufferFilled = true;
  
  if (!bufferFilled) return;
  
  // Calculate statistics
  float sum = 0;
  float maxVal = 0;
  for (int i = 0; i < WINDOW_SIZE; i++) {
    sum += magBuffer[i];
    if (magBuffer[i] > maxVal) maxVal = magBuffer[i];
  }
  float avg = sum / WINDOW_SIZE;
  
  String status = getStatus(mag);
  
  // Track anomalies
  if (status == "CRITICAL" || status == "WARNING") {
    if (millis() - lastAnomaly > 5000) {  // New anomaly window
      anomalyCount++;
      lastAnomaly = millis();
    }
  }
  
  // Display update
  display.clearDisplay();
  display.setCursor(0,0);
  display.println("Vibration Monitor");
  display.println("----------------");
  display.print("Status: ");
  display.println(status);
  display.print("Current: ");
  display.println(mag, 2);
  display.print("Average: ");
  display.println(avg, 2);
  display.print("Anomalies: ");
  display.println(anomalyCount);
  display.display();
  
  // Serial logging
  Serial.printf("%lu,%.3f,%.3f,%s,%d\n", 
                millis(), mag, avg, status.c_str(), anomalyCount);
  
  delay(100);
}
```

---

## Check Your Knowledge

!!! question "Q1 – Moving Average Trade-off"
    What's the downside of using a larger window size (e.g., 50 samples vs 10)?
    ??? tip "Answer"
        Larger windows provide smoother data but increase lag – you'll detect anomalies slower. Critical for real-time safety systems where 1-second delay matters.

!!! question "Q2 – Threshold Calibration"
    Why can't you use fixed thresholds (e.g., 1.8 g) for all trucks?
    ??? tip "Answer"
        Different trucks, tire wear, load weights, and road conditions produce different baseline vibration. Each truck needs calibration period (20-50 samples) to establish its normal range.

!!! question "Q3 – Predictive vs Reactive"
    How does this system provide *predictive* maintenance, not just alerts?
    ??? tip "Answer"
        By tracking anomaly count over time, you can schedule maintenance when count reaches 5-10 (tire imbalance developing), not waiting for catastrophic failure.

---

## Assessment 3 Submission (Due End of Week 8)

**Submit to GitHub + Blackboard:**

1. **Design documentation** (3-4 pages):
   - System architecture diagram (GY-521 + ultrasonic + OLED on I²C bus)
   - Test plan with pass/fail criteria
   - Compatibility evaluation: GPIO usage, I²C addressing, power budget

2. **Code:** Complete predictive maintenance system with filtering and anomaly detection

3. **Test results** (CSV + graphs):
   - Baseline vibration data (20+ samples normal operation)
   - Induced anomaly test (shake ESP32 or attach to vibrating motor)
   - Graphs showing raw vs filtered data, anomaly detection triggers

4. **Test video** (3-4 minutes):
   - OLED displaying real-time vibration status
   - Trigger WARNING level (moderate shake)
   - Trigger CRITICAL level (vigorous shake)
   - Show anomaly counter incrementing

5. **Fault rectification log:**
   - Document sensor calibration issues you encountered
   - Threshold tuning process (how you determined 1.2, 1.5, 1.8 values)
   - Any I²C addressing conflicts and resolution

**Mapping:** ICTIOT503 Element 3 – Produce design documentation, document I²C bus integration and compatibility evaluation.

---

**Navigation:** [← Week 7](07.md) | [Course Overview](../overview.md) | [Week 9 →](09.md)
